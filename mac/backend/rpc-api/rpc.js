// Generated by IcedCoffeeScript 1.3.1c
(function() {
  var Communicator, callbacks, communicator, execute, executeJSON, get, handleCallbackTimeout, nextCallbackId, timeouts, _callbackTimeout, _exit,
    __slice = [].slice;

  Communicator = require('../lib/communicator').Communicator;

  communicator = null;

  callbacks = {};

  timeouts = {};

  nextCallbackId = 1;

  _callbackTimeout = null;

  _exit = null;

  get = function(object, path) {
    var component, _i, _len, _ref;
    _ref = path.split('.');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      component = _ref[_i];
      object = object[component];
      if (!object) throw new Error("Cannot find " + path);
    }
    if (object.call == null) throw new Error("" + path + " is not callable");
    return object;
  };

  exports.init = function(streams, exit, _arg) {
    var callbackTimeout, consoleDebuggingMode, _ref;
    _ref = _arg != null ? _arg : {}, callbackTimeout = _ref.callbackTimeout, consoleDebuggingMode = _ref.consoleDebuggingMode;
    _callbackTimeout = callbackTimeout != null ? callbackTimeout : 2000;
    _exit = exit;
    communicator = new Communicator(streams.stdin, streams.stdout, streams.stderr, executeJSON, consoleDebuggingMode);
    return communicator.on('end', function() {
      return exit(0);
    });
  };

  exports.exit = function(rv) {
    return _exit(rv);
  };

  exports.send = function(message, arg, callback) {
    var callbackId;
    if (callback == null) callback = null;
    if (typeof message !== 'string') {
      throw new Error("Invalid type of message: " + message);
    }
    if (callback) {
      callbackId = "$" + nextCallbackId++;
      callbacks[callbackId] = callback;
      return communicator.send([message, arg, callbackId]);
    } else {
      return communicator.send([message, arg]);
    }
  };

  exports.execute = execute = function() {
    var args, callback, message, _i;
    message = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
    message = message.replace(/\.(\w+)$/, '.api.$1');
    try {
      return get(LR, message).apply(null, __slice.call(args).concat([callback]));
    } catch (e) {
      return callback(e);
    }
  };

  executeJSON = function(json, callback) {
    var arg, command, func;
    command = json[0], arg = json[1];
    if (command && typeof command === 'string') {
      if (command[0] === '$') {
        if (func = callbacks[command]) {
          if (timeouts[command]) clearTimeout(timeouts[command]);
          delete timeouts[command];
          delete callbacks[command];
          func(null, arg);
          return callback(null);
        } else {
          return callback(new Error("Unknown or duplicate callback received"));
        }
      } else {
        return execute(command, arg, callback);
      }
    } else {
      return callback(new Error("Invalid JSON received"));
    }
  };

  handleCallbackTimeout = function(callbackId) {
    var func;
    func = callbacks[callbackId];
    delete timeouts[callbackId];
    delete callbacks[callbackId];
    return func(new Error("timeout"));
  };

}).call(this);
