Path = require 'path'
fs   = require 'fs'
util = require 'util'
clc  = require 'cli-color'


RegExp_escape = (str) ->
  str.replace(///(  [ / ' * + ? | ( ) \[ \] { } . ^ $ ]  )///g, '\\$1')

class Filter
  constructor: (string) ->
    @included = (string[0] != '!')
    if not @included
      string = string.substr(1)

    @regexp = new RegExp('^' + string.split('*').map(RegExp_escape).join('.*') + '$')

  matches: (string) ->
    @regexp.test(string)

class FilterList
  constructor: (string) ->
    @filters = (new Filter(s.trim()) for s in string.split(','))

  matches: (string) ->
    level = 'none'
    for filter in @filters
      if filter.matches string
        return filter.included
    return false


class Colorizer
  constructor: ->
    @colors = ['cyan', 'green', 'yellow', 'blue', 'magenta', 'red']
    @nextColor = 0

  next: ->
    color = @colors[@nextColor++ % @colors.length]
    return clc[color]


spaces = (len) ->
  new Array(len + 1).join(' ')

pad = (len, string) ->
  if string.length < len
    string + spaces(len - string.length)
  else
    string


formatters =
  '%s': (s) -> '' + s
  '%j': (s) -> JSON.stringify(s)
  '%d': (s) -> +s

formatAsConsole = (args) ->
  if typeof args[0] is 'string'
    fmt = args.shift()

  args = for arg in args
    if typeof arg is 'object'
      util.inspect(arg)
    else
      '' + arg

  if fmt
    args.unshift fmt.replace /%[sdj]/g, (s) -> if args.length > 0 then formatters[s](args.shift()) else s

  return args.join(' ')


class DreamLog

  constructor: ->
    @_modules = {}
    @_moduleColors = {}
    @_destinations = []
    @_colorizer = new Colorizer()

    @logger = @logger.bind(@)
    @logger.map = @map.bind(@)
    @logger.into = @into.bind(@)

    @logLevels = ['error', 'warn', 'info', 'debug']

    if filter = process.env['LOG_STDOUT']
      @into 'stdout', 'pretty', filter
    if filter = process.env['LOG_STDERR']
      @into 'stderr', 'pretty', filter
    if spec = process.env['LOG']
      @intoWithString spec

  map: (name, path) ->
    @_modules[path] = name


  determineModuleName: (path) ->
    path = original = fs.realpathSync(path)

    if @_modules.hasOwnProperty(path)
      return @_modules[path]

    until (path = Path.dirname(path)) is '/'
      suffix = original.substr(path.length + 1)

      if @_modules.hasOwnProperty(path)
        return @_modules[path] + '/' + suffix

      packageJson = Path.join(path, 'package.json')
      if Path.existsSync(packageJson)
        manifest = JSON.parse(fs.readFileSync(packageJson, 'utf8'))
        if manifest.name
          return manifest.name + '/' + suffix

      if Path.basename(path) is 'node_modules'
        return suffix

    throw new Error('Path not mapped to any module name: ' + original)


  logger: (moduleOrName) ->
    unless moduleOrName
      throw new Error "Dreamlog must be called with 'module' as an argument"

    unless typeof moduleOrName is 'string'
      moduleOrName = @determineModuleName(moduleOrName.filename)

    @_moduleColors[moduleOrName] ||= @_colorizer.next()
    new Logger this, { module: moduleOrName }


  format: (level, msg, data={}) ->
    data.time  ||= new Date()
    data.level ||= level
    data.msg   ||= msg

    if typeof data.time is 'number'
      data.time = new Date(date.time)
    if data.time instanceof Date
      data.time = data.time.toISOString()

    for own key, value of data
      if typeof value is 'object'
        if value.toLogString
          value = value.toLogString()
        else
          try
            value = JSON.stringify(value)
          catch e
            try
              value = '' + value
            catch e
              value = '[' + (value?.constructor?.name || 'Object') + ']'
        data[key] = value

    msg = data.msg
    for own key, value of data
      msg = msg.replace('{' + key + '}', value)

    ext =
      color: @_moduleColors[data.module] || ((s) -> s)

    return [msg, data, ext]


  write: (level, msg, data={}) ->
    [msg, data, ext] = @format(level, msg, data)

    for destination in @_destinations
      destination.add msg, data, ext


  createStore: (file, format=null) ->
    stream = switch file
      when 'stderr' then process.stderr
      when 'stdout' then process.stdout
      else fs.createWriteStream file, flags: 'a'

    unless format
      format = if stream in ['stderr', 'stdout'] then 'pretty' else 'json'

    switch format
      when 'json'   then new JSONFileStore(stream)
      when 'pretty' then new FormattedStreamStore(stream, yes)
      when 'boring' then new FormattedStreamStore(stream, no)


  intoStore: (store, filter) ->
    @_destinations.push new Destination(this, filter, store)
    return this

  into: (file, format, filter='*') ->
    @intoStore @createStore(file, format), filter

  intoWithString: (string) ->
    for item in string.split(';')
      fields = item.trim().split(':')

      file = fields.pop()
      @into file, fields[1], fields[0]

  hook: ->
    @consoleLogger ||= @logger('console')


    console.error = (args...) => @consoleLogger.error formatAsConsole(args)
    console.warn  = (args...) => @consoleLogger.warn  formatAsConsole(args)
    console.info  = (args...) => @consoleLogger.info  formatAsConsole(args)
    console.log   = (args...) => @consoleLogger.debug formatAsConsole(args)

    @utilLogger ||= @logger('util.debug')
    util.debug = (msg) => @utilLogger.debug "#{msg}"


class Logger

  constructor: (@dreamlog, @defaults) ->

  write: (level, msg, data={}) ->
    for own key, value of @defaults
      unless data.hasOwnProperty(key)
        data[key] = value
    @dreamlog.write level, msg, data

  ns: (data) ->
    for key, value of @defaults
      unless data.hasOwnProperty(key)
        data[key] ?= value

    return new Logger @dreamlog, data

  error: (msg, data) -> @write 'error', msg, data
  warn:  (msg, data) -> @write 'warn',  msg, data
  info:  (msg, data) -> @write 'info',  msg, data
  debug: (msg, data) -> @write 'debug', msg, data

  omg:   (msg, data) -> @write 'error', msg, data
  wtf:   (msg, data) -> @write 'warn',  msg, data
  fyi:   (msg, data) -> @write 'info',  msg, data


class Destination
  constructor: (@dreamlog, filterString, @store) ->
    @filter = new FilterList(filterString)
    @occurred = {}

  matches: (data) ->
    if data.level is 'warn' or data.level is 'error'
      yes
    else
      @filter.matches(data.module)

  add: (msg, data, ext) ->
    if @matches(data)
      @store.add msg, data, ext
    else if !@occurred[data.module]
      @occurred[data.module] = yes

      [msg, data, ext] = @dreamlog.format('info', "verbose logging off", { module: data.module })
      @store.add msg, data, ext


class FormattedStreamStore

  constructor: (@stream, @colored) ->
    @levels =
      'info':  'info'
      'error': 'OMG'
      'warn':  'WTF'

  add: (msg, data, { color }) ->
    time = data.time.substr(0, 19)

    level = pad(5, @levels[data.level] || data.level)
    module = data.module

    if @colored
      if data.level is 'error'
        level = clc.bold(clc.red(level))
        time = clc.red(time)
      else if data.level is 'warn'
        level = clc.bold(level)

      module = color(module)

    @stream.write "#{time} #{level} #{module} â€” #{msg}\n"


class JSONFileStore

  constructor: (@stream) ->

  add: (msg, data, ext) ->
    @stream.write JSON.stringify(data) + "\n"


module.exports = DreamLog
