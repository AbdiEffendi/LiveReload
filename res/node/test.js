// Generated by IcedCoffeeScript 1.3.3e
(function() {
  var Communicator, EventEmitter, communicator, executeJSON, fs,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  fs = require('fs');

  EventEmitter = require('events').EventEmitter;

  Communicator = (function(_super) {

    __extends(Communicator, _super);

    function Communicator(stdin, stdout, stderr, execute, consoleDebuggingMode) {
      var _this = this;
      this.stdin = stdin;
      this.stdout = stdout;
      this.stderr = stderr;
      this.execute = execute;
      this.consoleDebuggingMode = consoleDebuggingMode != null ? consoleDebuggingMode : false;
      this.stdin.resume();
      this.stdin.setEncoding('utf8');
      this.commandsInFlight = 0;
      this.buffer = "";
      this.stdin.on('data', function(chunk) {
        var line, lines, _i, _j, _len, _ref, _results;
        _ref = (_this.buffer + chunk).split("\n"), lines = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), _this.buffer = _ref[_i++];
        _results = [];
        for (_j = 0, _len = lines.length; _j < _len; _j++) {
          line = lines[_j];
          _results.push(_this.processLine(line));
        }
        return _results;
      });
      this.stdin.on('end', function() {
        process.stderr.write("KTNXBYE\n");
        return _this.emit('end');
      });
    }

    Communicator.prototype.processLine = function(line) {
      var command;
      if (line === '') return;
      if (!line.match(/"app\.ping"/)) {
        if (!this.consoleDebuggingMode) {
          process.stderr.write("App to Node: " + line + "\n");
        }
      }
      command = JSON.parse(line);
      return this.processCommand(command, function(err) {
        if (err) {
          process.stderr.write("Error encountered while processing incoming command: " + err.message + ". Will die.\n");
        }
        if (err) throw err;
      });
    };

    Communicator.prototype.processCommand = function(command, callback) {
      var _this = this;
      this.beforeCommand();
      return this.execute(command, function(err, reply) {
        _this.afterCommand();
        return callback(err);
      });
    };

    Communicator.prototype.beforeCommand = function() {
      return ++this.commandsInFlight;
    };

    Communicator.prototype.afterCommand = function() {
      --this.commandsInFlight;
      if (this.commandsInFlight === 0) return this.emit('idle');
    };

    Communicator.prototype.send = function(command) {
      var buf, payload;
      if (typeof command[0] !== 'string') {
        throw new Error("Invalid type of message: " + command);
      }
      payload = JSON.stringify(command);
      buf = new Buffer("" + payload + "\n");
      if (!this.consoleDebuggingMode) {
        process.stderr.write("Node to App: " + payload + "\n");
      }
      return this.stdout.write("" + payload + "\n");
    };

    return Communicator;

  })(EventEmitter);

  executeJSON = function(json) {
    return communicator.send(['gotcha', json]);
  };

  communicator = new Communicator(process.stdin, process.stdout, process.stderr, executeJSON, false);

  communicator.on('end', function() {
    return process.exit(0);
  });

  setInterval(function() {
    return communicator.send(['hello', "Now is " + Date.now()]);
  }, 1000);

}).call(this);
