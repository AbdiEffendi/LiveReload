// Generated by IcedCoffeeScript 1.3.3f
(function() {
  var Communicator, EventEmitter, Executor, Path, S, State, communicator, executor, fs, log, sendUpdate,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  fs = require('fs');

  Path = require('path');

  EventEmitter = require('events').EventEmitter;

  Communicator = (function(_super) {

    __extends(Communicator, _super);

    function Communicator(stdin, stdout, stderr, execute, consoleDebuggingMode) {
      var _this = this;
      this.stdin = stdin;
      this.stdout = stdout;
      this.stderr = stderr;
      this.execute = execute;
      this.consoleDebuggingMode = consoleDebuggingMode != null ? consoleDebuggingMode : false;
      this.stdin.resume();
      this.stdin.setEncoding('utf8');
      this.commandsInFlight = 0;
      this.buffer = "";
      this.stdin.on('data', function(chunk) {
        var line, lines, _i, _j, _len, _ref, _results;
        _ref = (_this.buffer + chunk).split("\n"), lines = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), _this.buffer = _ref[_i++];
        _results = [];
        for (_j = 0, _len = lines.length; _j < _len; _j++) {
          line = lines[_j];
          _results.push(_this.processLine(line));
        }
        return _results;
      });
      this.stdin.on('end', function() {
        process.stderr.write("KTNXBYE\n");
        return _this.emit('end');
      });
    }

    Communicator.prototype.processLine = function(line) {
      var command;
      if (line === '') return;
      if (!line.match(/"app\.ping"/)) {
        if (!this.consoleDebuggingMode) {
          process.stderr.write("App to Node: " + line + "\n");
        }
      }
      command = JSON.parse(line);
      return this.processCommand(command, function(err) {
        if (err) {
          process.stderr.write("Error encountered while processing incoming command: " + err.message + ". Will die.\n");
        }
        if (err) throw err;
      });
    };

    Communicator.prototype.processCommand = function(command, callback) {
      var _this = this;
      this.beforeCommand();
      return this.execute(command, function(err, reply) {
        _this.afterCommand();
        return callback(err);
      });
    };

    Communicator.prototype.beforeCommand = function() {
      return ++this.commandsInFlight;
    };

    Communicator.prototype.afterCommand = function() {
      --this.commandsInFlight;
      if (this.commandsInFlight === 0) return this.emit('idle');
    };

    Communicator.prototype.send = function(command) {
      var buf, payload;
      if (typeof command[0] !== 'string') {
        throw new Error("Invalid type of message: " + command);
      }
      payload = JSON.stringify(command);
      buf = new Buffer("" + payload + "\n");
      if (!this.consoleDebuggingMode) {
        process.stderr.write("Node to App: " + payload + "\n");
      }
      return this.stdout.write("" + payload + "\n");
    };

    return Communicator;

  })(EventEmitter);

  State = (function() {

    function State() {
      this.stateFile = 'livereload-state.json';
      this.nextProjectId = 1;
      this.projectList = [
        {
          "id": "P" + (this.nextProjectId++),
          "name": "SomeProject",
          "path": "C:/Users/tima/!Work/SomeProject"
        }, {
          "id": "P" + (this.nextProjectId++),
          "name": "AnotherProject",
          "path": "C:/Users/tima/!Work/AnotherProject"
        }
      ];
    }

    State.prototype.memento = function() {
      return {
        projectList: this.projectList,
        nextProjectId: this.nextProjectId
      };
    };

    State.prototype.setMemento = function(memento) {
      this.projectList = memento.projectList;
      return this.nextProjectId = memento.nextProjectId;
    };

    State.prototype.save = function() {
      return fs.writeFileSync(this.stateFile, JSON.stringify(this.memento(), null, 2));
    };

    State.prototype.load = function() {
      try {
        this.setMemento(JSON.parse(fs.readFileSync(this.stateFile, 'utf8')));
        return log("Loaded saved state.");
      } catch (e) {
        return log("Created brand new state, yu-huu!");
      }
    };

    return State;

  })();

  S = new State();

  log = function(message) {
    communicator.send(['hello', "" + message + "  (at " + (Date.now()) + ")"]);
    return void 0;
  };

  sendUpdate = function() {
    communicator.send([
      'update', {
        projects: S.projectList
      }
    ]);
    return S.save();
  };

  Executor = (function() {

    function Executor() {}

    Executor.prototype.executeJSON = function(_arg) {
      var arg, command;
      command = _arg[0], arg = _arg[1];
      return this["on " + command].call(this, arg);
    };

    Executor.prototype['on projects.add'] = function(_arg) {
      var path;
      path = _arg.path;
      if (!path) return log("Missing 'path' in projects.add!");
      S.projectList.push({
        id: "P" + (S.nextProjectId++),
        name: Path.basename(path),
        path: path
      });
      log("Added!");
      return sendUpdate();
    };

    Executor.prototype['on projects.remove'] = function(_arg) {
      var id, index, project, _i, _len, _ref;
      id = _arg.id;
      if (!id) return log("Missing 'id' in projects.remove!");
      _ref = S.projectList;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        project = _ref[index];
        if (project.id === id) {
          S.projectList.splice(index, 1);
          sendUpdate();
          log("Removed!");
          return;
        }
      }
      return log("Project with id '" + id + "' not found!");
    };

    return Executor;

  })();

  executor = new Executor();

  communicator = new Communicator(process.stdin, process.stdout, process.stderr, executor.executeJSON.bind(executor), false);

  communicator.on('end', function() {
    return process.exit(0);
  });

  S.load();

  sendUpdate();

}).call(this);
