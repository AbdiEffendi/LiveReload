// Generated by IcedCoffeeScript 1.3.1c
(function() {
  var MessageFormat, ToolMessage, ToolOutput, WILDCARDS, util,
    __slice = [].slice;

  util = require('util');

  WILDCARDS = {
    file: '[^\\n]+?',
    line: '\\d+',
    message: '\\S[^\\n]+?'
  };

  ToolMessage = (function() {

    function ToolMessage() {
      this.message = this.file = this.line = null;
    }

    ToolMessage.prototype.toString = function() {
      return util.inspect(this);
    };

    ToolMessage.prototype.toJSON = function() {
      return {
        message: this.message,
        file: this.file,
        line: this.line
      };
    };

    return ToolMessage;

  })();

  exports.ToolOutput = ToolOutput = (function() {

    function ToolOutput(raw) {
      this.raw = raw;
      this.warnings = [];
      this.error = null;
      this.parsed = false;
    }

    ToolOutput.prototype.toString = function() {
      return util.inspect({
        warnings: this.warnings,
        error: this.error
      });
    };

    ToolOutput.prototype.toJSON = function() {
      var _ref;
      return {
        raw: this.raw,
        warnings: this.warnings.map('toJSON'),
        error: (_ref = this.error) != null ? _ref.toJSON() : void 0
      };
    };

    return ToolOutput;

  })();

  MessageFormat = (function() {

    function MessageFormat(pattern) {
      var index,
        _this = this;
      this.pattern = pattern;
      this.indices = {};
      this.overrides = {};
      this.used = false;
      index = 1;
      this.processedPattern = this.pattern.replace(/<ESC>/g, '').replace(/\(\(([\w-]+)(?::(.*?))?\)\)/gm, function(_, name, content) {
        var replacement;
        if (name === 'message-override') {
          _this.overrides['message'] = content;
          return '';
        }
        if (replacement = WILDCARDS[name]) {
          _this.indices[name] = index;
        } else {
          throw new Error("Unknown wildcard: '" + name + "'");
        }
        index++;
        if (content) {
          content = content.replace('***', replacement);
          return "(" + content + ")";
        } else {
          return "(" + replacement + ")";
        }
      });
      this.regexp = new RegExp(this.processedPattern, 'ig');
    }

    MessageFormat.prototype.forEachMatch = function(text, callback) {
      var _this = this;
      return text.replace(this.regexp, function() {
        var index, key, match, message, value, _ref, _ref1;
        match = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        message = new ToolMessage();
        _ref = _this.indices;
        for (key in _ref) {
          index = _ref[key];
          message[key] = match[index];
        }
        _ref1 = _this.overrides;
        for (key in _ref1) {
          value = _ref1[key];
          message[key] = value.replace('***', message[key] || '');
        }
        callback(message);
        return "";
      });
    };

    return MessageFormat;

  })();

  exports.MessageParser = (function() {

    function MessageParser(compilerManifest) {
      var pattern;
      this.errorFormats = (function() {
        var _i, _len, _ref, _results;
        _ref = compilerManifest.Errors;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pattern = _ref[_i];
          _results.push(new MessageFormat(pattern));
        }
        return _results;
      })();
      this.warningFormats = (function() {
        var _i, _len, _ref, _results;
        _ref = compilerManifest.Warnings || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pattern = _ref[_i];
          _results.push(new MessageFormat(pattern));
        }
        return _results;
      })();
    }

    MessageParser.prototype.parse = function(text) {
      var format, output, _i, _j, _len, _len1, _ref, _ref1;
      output = new ToolOutput(text);
      text = text.trim() + "\n";
      _ref = this.warningFormats;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        format = _ref[_i];
        text = format.forEachMatch(text, function(message) {
          return output.warnings.push(message);
        });
      }
      if (text.trim().length === 0) {
        output.parsed = true;
      } else {
        _ref1 = this.errorFormats;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          format = _ref1[_j];
          text = format.forEachMatch(text, function(message) {
            if (!output.error) {
              output.error = message;
              return output.parsed = true;
            }
          });
        }
      }
      if (output.warnings.length > 0) output.parsed = true;
      return output;
    };

    return MessageParser;

  })();

}).call(this);
