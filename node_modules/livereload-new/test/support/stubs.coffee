{deepEqual} = require 'assert'

_stubs = null

beforeEach ->
  _stubs = []

afterEach ->
  for stub in _stubs
    stub.verify()

class Expectation
  constructor: ({ @funcs, @retVal, @args }) ->

  apply: (object, args) ->
    if @args?
      deepEqual args, @args

    for func in @funcs
      rv = func.apply(object, args)
      if typeof rv isnt 'undefined'
        retVal = rv
    retVal = @retVal  if typeof(@retVal) isnt 'undefined'


class Stub
  constructor: (@object, @methodName) ->
    @object[@methodName] = @call.bind(@)
    @object["expect_#{@methodName}"] = @expect.bind(@)

    @_expectations = []

  call: (args...) ->
    if expectation = @_expectations.shift()
      return expectation.apply(@object, args)
    else
      argsRepr = (JSON.stringify(arg) for arg in args).join(", ")
      throw new Error "Unexpected call to #{@methodName}(#{argsRepr})"

  expect: (args...) ->
    options = { funcs: [], retVal: undefined, args: undefined }

    arg = args.shift()
    while typeof arg is 'function'
      options.func = arg
      arg = args.shift()

    if (typeof arg is 'object') and Array.isArray(arg)
      options.args = arg
      arg = args.shift()

    options.retVal = arg
    arg = args.shift()

    if args.length > 0
      throw new Error "Invalid number of arguments to #{@methodName}.expect"

    @_expectations.push new Expectation(options)

  verify: ->
    if @_expectations.length > 0
      throw new Error "#{@_expectations.length} unmatched expectation(s) for #{@methodName}: " + JSON.stringify(@_expectations, null, 2)


exports.stub = stub = (object, methodName) ->
  _stubs.push new Stub(object, methodName)
  undefined


exports.hookService = (service) ->
  stub service, 'send'
  return service
