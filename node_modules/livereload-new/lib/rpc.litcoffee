# Remote Services

LiveReload is split into multiple isolated services that don't share any state. (That is, they do send the state back and forth, they just don't share any state implicitly.)

The services can share the same process and JavaScript enviroment, or run out-of-process and communicate over file streams, network streams or XPC.

A single endpoint exposes one or more services.


## Preamble

    debug = require('debug')('livereload:rpc')

    _ = require 'underscore'

    {EventEmitter} = require 'events'


## Connection

    exports.createConnection = createConnection = (transport) ->
      new RpcConnection(transport)



    class RpcConnection extends EventEmitter

      constructor: (@transport) ->
        @callbackTimeout = 2000
        @nextCallbackId = 1
        @callbacks = {}
        @timeouts  = {}
        @commandsInFlight = 0
        @services = {}

        @transport.on 'message', (message) =>
          @_executeWithProtection message

        @transport.on 'end', =>
          @emit 'end'

      publish: (service) ->
        if !service.name then throw new Error "service.name must be defined"
        service.send = @send.bind(@)
        @services[service.name] = service
        debug "Published service '#{service.name}'"

      provide: (serviceClass) ->
        throw new Error "TODO"


      registerCallback: (callback) ->
        callbackId = "$" + @nextCallbackId++
        @callbacks[callbackId] = callback
        return callbackId

      freeCallback: (callbackId) ->
        delete @callbacks[callbackId]
        if timerId = @timeouts[callbackId]
          clearTimeout(timerId)
          delete @timeouts[callbackId]

      registerOneTimeCallback: (callback, timeout) ->
        wrapperCallback = (args...) =>
          @freeCallback(callbackId)
          return callback(null, args...)

        callbackId = @registerCallback(wrapperCallback)

        if timeout
          @timeouts[callbackId] = setTimeout((-> wrapperCallback new Error("timeout")), @callbackTimeout)

        return callbackId


      send: (message, arg, callback=null) ->
        if typeof message isnt 'string'
          throw new Error("Invalid type of message: #{message}")

        debug "RpcConnection.send: %s, %j", message, arg

        self = this
        Function::toJSON = -> self.registerCallback(this)

        if callback  #args.length > 0 && typeof args[args.length - 1] is 'function'
          # timeouts temporarily disabled because they prevent displayPopupMessage call from returning useful data
          timeout = null
          @_doSend [message, arg, @registerOneTimeCallback(callback, timeout)]
        else
          @_doSend [message, arg]

        delete Function::toJSON

      _doSend: (message) ->
        serviceName = message[0].split('.')[0]
        debug "serviceName = #{serviceName}"
        if @services.hasOwnProperty(serviceName)
          message = JSON.parse(JSON.stringify(message))  # deep clone + use toJSON
          process.nextTick @_executeWithProtection.bind(@, message)
        else
          @transport.send message


      _executeWithProtection: (message) ->
        try
          @_execute message, @_doneExecutingWithProtection.bind(@)
        catch e
          @_handleException e

      _doneExecutingWithProtection: (err) ->
        if err
          @_handleException err

      _handleException: (err) ->
        @emit 'error', err


      _execute: ([command, arg, replyCallbackId], callback) ->
        debug "RpcConnection._execute: %s, %j, %j", command, arg, replyCallbackId
        if command && typeof command is 'string'
          if command[0] is '$'
            @_executeCallback(command, arg, callback)
          else if command[0] is '-'
            @freeCallback(command.substr(1))
          else
            @_executeCommand(command, arg, replyCallbackId, callback)
        else
          callback(new Error("Invalid JSON received"))


      _executeCallback: (command, arg, callback) ->
        if func = @callbacks[command]
          func arg
          callback(null)
        else
          callback(new Error("Unknown or duplicate callback received"))


      _executeCommand: (command, arg, replyCallbackId, callback) ->
        ++@commandsInFlight

        components = command.split('.')
        if components.length != 2 then throw new Error "commands must have service.methodName format: #{JSON.stringify command}"
        [serviceName, methodName] = components

        if !@services.hasOwnProperty(serviceName) then throw new Error "unknown service name in command: #{JSON.stringify command}"
        service = @services[serviceName]

        method = service[methodName]
        if typeof(method) isnt 'function' then throw new Error "unknown method name in command: #{JSON.stringify command}"

        try
          method.call(service, arg, @_doneExecutingCommand.bind(@, callback, replyCallbackId))
        catch err
          @_doneExecutingCommand(callback, replyCallbackId, err)


      _doneExecutingCommand: (callback, replyCallbackId, err, result) ->
        --@commandsInFlight

        if replyCallbackId
          @send replyCallbackId, (if err then { err } else result)

        # emit on next tick so that the callback has time to run first
        # (useful for testing, so that the callback can be the first to throw an assertion)
        if @commandsInFlight is 0
          process.nextTick =>
            if @commandsInFlight is 0
              @emit 'idle'

        callback(err)


## JsonStreamTransport

    exports.createJsonStreamTransport = createJsonStreamTransport = (inputStream, outputStream) ->
      new JsonStreamTransport(inputStream, outputStream)

    exports.createJsonStreamConnection = (inputStream, outputStream) ->
      createConnection(createJsonStreamTransport(inputStream, outputStream))

    class JsonStreamTransport extends EventEmitter

      # kind of like Pascal :-)
      constructor: (@input, @output) ->
        @input.setEncoding('utf8')
        @input.resume()
        @buffer = ""

        @input.on 'data', (chunk) =>
          [lines..., @buffer] = (@buffer + chunk).split("\n")
          for line in lines
            @_processLine line

        @input.on 'end', =>
          @emit 'end'


      _processLine: (line) ->
        return if line == ''  # empty lines are handy when testing in console mode

        unless line.match /"app\.ping"/
          debug "App to Node: %s", line
        command = JSON.parse(line)
        @emit 'message', command


      send: (command) ->
        if typeof command[0] isnt 'string'
          throw new Error("Invalid type of message: #{command}")
        payload = JSON.stringify(command)
        buf = new Buffer("#{payload}\n")
        debug "Node to App: %s", payload
        @output.write "#{payload}\n"


## MockTransport

    exports.createMockTransport = createMockTransport = (options) ->
      new MockTransport(options)


    class MockTransport extends EventEmitter
      constructor: (options={}) ->
        @strict = options.strict ? no
        @messages = []
        @expectations = []
        @nextOrdinal = 1
        @lastCallback = null
        @timer = null

        {@ok, @deepEqual} = require 'assert'

        @i = @i.bind(this)
        @o = @o.bind(this)
        @timeout   = @timeout.bind(this)
        @reply     = @reply.bind(this)
        @transport = this  # make life easy for those using destructive assingments

      send: (message) ->
        @messages.push message
        @emit 'sent', message
        if message[2]
          @lastCallback = message[2]

        best = { expectation: null, score: 0 }
        for expectation in @expectations
          score = expectation.score(message[0], message[1])
          if score > best.score
            best = { expectation, score }

        if best.score >= SCORE_WILDCARD
          if best.score is SCORE_EXACT
            debug "Exact expectation match for %j", message
          else
            debug "Wildcard expectation match for %j, arg wildcard %j", message, best.expectation.arg
          @_matched(best.expectation)
        else
          if best.score < SCORE_CMD_MATCH
            debug "No match for %j", message
          else
            debug "No match for the arg of %j", message
            debug "Diff:\n%s", require('json-diff').diffString(best.expectation.arg, message[1])
          if @strict
            debug "All expectations:\n" + @expectations.join("\n")
            if best.score >= SCORE_CMD_MATCH
              @deepEqual message[1], best.expectation.arg
            else
              @ok no, "Unexpected message received: #{JSON.stringify(message)}"

      simulate: (message) ->
        @emit 'message', message

      expect: (command, arg, callback) ->
        if typeof callback isnt 'function'
          throw new Error "MockTransport#expect 3rd argument (callback) must be a function"
        @expectations.push new Expectation(@nextOrdinal++, callback, command, arg)
        @timeout()

      _matched: (expectation) ->
        @expectations = _.without @expectations, expectation
        expectation.callback()


      o: (command, arg, callback) -> @expect(command, arg, callback)
      i: (command, arg, cb) ->
        # nextTick provides a chance to call #o
        process.nextTick =>
          if cb
            @simulate([command, arg, cb])
          else
            @simulate([command, arg])

      reply: (arg) ->
        unless @lastCallback
          throw new Error "MockTransport#reply: no callback available"
        @i @lastCallback, arg
        @lastCallback = null

      timeout: (period=100) ->
        clearTimeout(@timer) if @timer
        limit = @nextOrdinal
        @timer = setTimeout (=>
          @timer = null
          unmatched = @expectations.filter((e) -> e.ordinal < limit)
          if unmatched.length > 0
            @ok no, "Expected commands not received within #{period}ms:" + ("\n  #{expectation}" for expectation in unmatched).join('') + "\n\nAll commands observed: " + JSON.stringify(@messages, null, 2) + "\n"
        ), period


Expectations and the similarity scores.

    SCORE_NO_MATCH  = 0
    SCORE_CMD_MATCH = 10
    SCORE_WILDCARD  = 900
    SCORE_EXACT     = 1000

    class Expectation
      constructor: (@ordinal, @callback, @command, @arg) ->
        @argString = JSON.stringify(@arg, stableOrderReplacer)

      toString: ->
        "Expectation(#{JSON.stringify(@command)}, #{@argString})"

      score: (command, arg) ->
        if @command isnt command
          SCORE_NO_MATCH
        else if @arg is '*'
          SCORE_WILDCARD
        else if (JSON.stringify(arg, stableOrderReplacer) != @argString)
          SCORE_CMD_MATCH
        else
          SCORE_EXACT

A little utility method to rebuild the objects during JSON serialization so that the keys get serialized in alphabetical order (thanks to V8's key ordering behavior).

    stableOrderReplacer = (key, value) ->
      return value unless value?.constructor is Object
      Object.keys(value).sort().reduce (sorted, key) ->
        sorted[key] = value[key]
        sorted
      , {}
