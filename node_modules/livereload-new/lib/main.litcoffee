# LiveReload backend entry point

Invoked by `bin/livereload.js` to process command-line options and launch the backend.


## Preamble

    debug = require('debug')('livereload:main')
    Path = require 'path'
    rpc = require './rpc'


## Run

There are no command-line options at the moment.

    exports.run = (argv) ->
      connection = rpc.createJsonStreamConnection(process.stdin, process.stdout)

      connection.on "end", -> shutdown()

      exposeServices(connection)


## Expose

Exposes all the bundled services on a given connection. This function can be called from integration tests to set up a full production environment with a more suitable transport.

    exports.exposeServices = exposeServices = (connection) ->
      Paths = {}
      Paths.rootDir = Path.dirname(__dirname)
      Paths.resourceDir = Path.join(Paths.rootDir, 'res')

      connection.publish require('./services/dummy').create()
      connection.publish require('./services/reloader').create()
      connection.publish require('./services/browser').create({ resourceDir: Paths.resourceDir, appVersion: '3.0.0' })
      connection.publish require('./services/stub').create('app', ['init', 'reloadLegacyProjects', 'handleChange'])


## Shutting down

This isn't really required because the service will be killed when the main app quits. (Is that true on a Mac? Certainly true on Windows, we're using a Job object to handle that.)

    shutdown = ->

Output a string to mark this point in the logs. We sometimes receive logs that just end abruptly at an arbitrary line, so it's important to signal whether backend shutdown has actually happened.

      debug "Backend shutdown."

Nobody's interested in this exit code anyway, so code zero is as good as any.

      process.exit 0

The use of `process.exit` here is quite questionable; for example, we might be in the middle of writing a file at the moment. On the other hand, the background processing time is unbounded; we may even be stuck in an endless async loop, and maybe that's why the user is shutting us down in the first place.

The best approach here would be to simulate ‘sudden termination’ semantics of OS X, setting a flag during dangerous operations like async file writes, but allowing an immediate shutdown at any other time.
