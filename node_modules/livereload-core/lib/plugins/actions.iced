class Action_Basics
  schema:
    tool:                    { type: 'Tool' }
    category:                { type: String }

  computeDefaultRules: ->
    []

class Project_Actions
  schema:
    availableActions:        { collection: 'list', type: 'Action' }
    actionInstances:         { collection: 'list', type: 'ActionInstance' }

  compute_actionInstances: ->
    []


class ActionInstance_Basics
  schema:
    action:                  { type: 'Action' }
    defaultRules:            { type: { array: 'Rule' } }

  compute_defaultRules: ->
    @action.computeDefaultRules()

class Rule_Basics
  schema:
    action:                  { type: 'Action' }
    actionInstance:          { type: 'ActionInstance' }
    steps:                   { type: 'Step' }

class Step_Basics
  schema:
    rule:                    { type: 'Rule' }
    pendingInvocations:      { collection: 'list', type: 'Invocation' }

  compute_pendingInvocations: ->
    []


class Invocation

  schema:
    step:                    { type: 'Step' }
    status:                  { type: String }

  @PENDING   = PENDING   = 'pending'
  @RUNNING   = RUNNING   = 'running'
  @FINISHED  = FINISHED  = 'finished'
  @CANCELLED = CANCELLED = 'cancelled'

  constructor: (@tool, @info) ->
    @messages  = []
    @status    = PENDING
    @error     = null
    @succeeded = no

  addMessages: (messages) ->
    @messages.push.apply(@messages, messages)
    for message in messages when message.type is 'error'
      if not @error
        @error = message
    @emit "messages:changed"

  run: ->
    @status = RUNNING
    @tool.invoke this, =>
      @succeeded = yes unless @error
      @status = FINISHED
      @emit 'finished'


exports.definitions = [
  { name: 'Tool', duck: { isLiveReloadTool: yes } }
  Action_Basics
  ActionInstance_Basics
  Rule_Basics
  Step_Basics
  Invocation
]
