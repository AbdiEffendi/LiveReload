_ = require 'underscore'
debug = require('debug')('reactive')
{EventEmitter} = require 'events'


module.exports = R =
  VERSION: '0.0.0'


R.kindFromClass = (klass) ->
  # We rely on Function::name, which is a non-standard property supported by everyone except IE
  # (and can be emulated by parsing Function::toString if necessary).
  unless klass.name
    throw new Error "R requires entity classes to have a non-empty 'name'"

  # Entity name ends with the first underscore. Everything else is a SmallTalk/ObjC-style ‘category name’,
  # or a ‘mixin name’ if you will.
  return klass.name.replace(/_.*$/, '')


# A top-level context that contains all reactive stuff.
R.Universe = class RUniverse
  # Assign a unique ID to each Universe to help debugging tests (which typically create a new universe for each test).
  _nextUniverseId = 1

  constructor: ->
    @_id = "RUniverse" + (_nextUniverseId++)
    @kinds = {}

  # For debugging only.
  toString: -> @_id

  # Initiate a singularity.
  dispose: ->


  # Register the given klass.
  register: (klass) ->
    kind = R.kindFromClass(klass)

    # We may have multiple classes for the same entity, they will be all merged together (kinda like Ruby modules).
    if @kinds.hasOwnProperty(kind)
      schema = @kinds[kind]
    else
      schema = @kinds[kind] = new REntitySchema(kind)
    schema.addClass klass

    return schema


# Stores all the information known about a specific kind (by a specific universe).
class REntitySchema
  constructor: (@kind) ->
    @klasses = []

  # For debugging only.
  toString: -> "REntitySchema(#{@kind})"

  addClass: (klass) ->
    if @klasses.indexOf(klass) < 0
      @klasses.push klass
