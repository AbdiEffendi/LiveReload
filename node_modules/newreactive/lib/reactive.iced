_ = require 'underscore'
debug = require('debug')('reactive')
{EventEmitter} = require 'events'


module.exports = R =
  VERSION: '0.0.0'


# For convenience, entities support magic method names like `get myattr` (yes, with a space),
# which are automatically converted into options of the corresponding attributes.
# To help catch typos, an error is thrown if the attribute is not already defined.
# Here, `%` stands for the attribute name.
MAGIC_METHODS =
  getter: 'get %'
  setter: 'set %'
  compute: 'compute %'
  initializer: 'initialize %'


R.kindFromClass = (klass) ->
  # We rely on Function::name, which is a non-standard property supported by everyone except IE
  # (and can be emulated by parsing Function::toString if necessary).
  unless klass.name
    throw new Error "R requires entity classes to have a non-empty 'name'"

  # Entity name ends with the first underscore. Everything else is a SmallTalk/ObjC-style ‘category name’,
  # or a ‘mixin name’ if you will.
  return klass.name.replace(/_.*$/, '')


# A top-level context that contains all reactive stuff.
R.Universe = class RUniverse
  # Assign a unique ID to each Universe to help debugging tests (which typically create a new universe for each test).
  _nextUniverseId = 1

  constructor: ->
    @_id = "RUniverse" + (_nextUniverseId++)
    @kinds = {}

  # For debugging only.
  toString: -> @_id

  # Initiate a singularity.
  dispose: ->


  # Register the given klass.
  register: (klass) ->
    kind = R.kindFromClass(klass)

    # We may have multiple classes for the same entity, they will be all merged together (kinda like Ruby modules).
    if @kinds.hasOwnProperty(kind)
      schema = @kinds[kind]
    else
      schema = @kinds[kind] = new REntitySchema(kind)
    schema.addClass klass

    return schema


# Stores all the information known about a specific kind (by a specific universe).
class REntitySchema
  constructor: (@kind) ->
    @klasses = []
    @attributes = {}

  # For debugging only.
  toString: -> "REntitySchema(#{@kind})"

  addClass: (klass) ->
    if @klasses.indexOf(klass) < 0
      @klasses.push klass

      # `klass::schema` looks nicer in CoffeeScript class literals (just `schema: ...` instead of `@schema = ...`),
      # but klass.schema makes more sense, so let's convert the former into the latter.
      if !klass.schema and klass::schema
        klass.schema = klass::schema
        delete klass::schema

      @_addSchema(klass.schema or {}, klass.prototype)

  _addSchema: (schema, prototype) ->
    for own attrName, attrOptions of schema
      @_addAttribute attrName, attrOptions, prototype
    undefined

  _addAttribute: (attrName, attrOptions, prototype) ->
    # Convert magic methods into options.
    for own optionsKey, methodName of MAGIC_METHODS
      @_convertMethodIntoOption prototype, attrOptions, methodName.replace('%', attrName), optionsKey

    attrSchema = @attributes[attrName] = new RAttributeSchema(this, attrName, attrOptions)

  _convertMethodIntoOption: (prototype, options, methodName, optionsKey) ->
    if prototype.hasOwnProperty(methodName)
      options[optionsKey] = prototype[methodName]
      delete prototype[methodName]


class RAttributeSchema
  constructor: (@entitySchema, @name, @options) ->

  # For debugging only.
  toString: ->
    "RAttributeSchema(#{@name}, #{JSON.stringify(@options)})"
