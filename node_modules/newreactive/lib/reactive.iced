_ = require 'underscore'
debug = require('debug')('reactive')
{EventEmitter} = require 'events'
Domain = require 'domain'


module.exports = R =
  VERSION: '0.0.0'


# For convenience, entities support magic method names like `get myattr` (yes, with a space),
# which are automatically converted into options of the corresponding attributes.
# To help catch typos, an error is thrown if the attribute is not already defined.
# Here, `%` stands for the attribute name.
MAGIC_METHODS =
  getter: 'get %'
  setter: 'set %'
  compute: 'compute %'
  initializer: 'initialize %'


# Creates an empty subclass of the given superclass, with `.constructor.name` returning the given name.
createNamedSubclass = (name, superclass) ->
  if false
    # This would be a sane way to do this if Function.name was assignable under V8.
    class subclass extends superclass
    subclass.name = name
  else
    # The insane way to create a class.
    global.REACTIVE_CLASS_CREATION_HACK = superclass
    subclass = eval("(function(superclass) { return function #{name}() { superclass.apply(this, arguments); }; })(global.REACTIVE_CLASS_CREATION_HACK);")
    delete global.REACTIVE_CLASS_CREATION_HACK
    `__extends(subclass, superclass);`  # HACK: reuse CoffeeScript's internal method
  return subclass


R.kindFromClass = (klass) ->
  # We rely on Function::name, which is a non-standard property supported by everyone except IE
  # (and can be emulated by parsing Function::toString if necessary).
  unless klass.name
    throw new Error "R requires entity classes to have a non-empty 'name'"

  # Entity name ends with the first underscore. Everything else is a SmallTalk/ObjC-style ‘category name’,
  # or a ‘mixin name’ if you will.
  return klass.name.replace(/_.*$/, '')


# A top-level context that contains all reactive stuff.
R.Universe = class RUniverse
  # Assign a unique ID to each Universe to help debugging tests (which typically create a new universe for each test).
  _nextUniverseId = 1

  constructor: ->
    @_id = "RUniverse" + (_nextUniverseId++)
    @_nextIdPerClass = {}
    @kinds = {}
    @currentTask = null

  # For debugging only.
  toString: -> @_id

  # Initiate a singularity.
  dispose: ->


  # Generate a human-friendly unique id.
  #
  # A simple auto-incremented number would suffice here. However, for testing
  # and debugging purposes, we choose to:
  #
  # * use class name as a prefix
  # * scope autoincremented numbers to R.Universe (so that tests can rely on stable IDs)
  # * optionally append a user-defined suffix
  uniqueId: (className='', detail) ->
    detail = if detail then ('_' + detail).replace(/[^0-9a-zA-Z]+/g, '_') else ''

    @_nextIdPerClass[className] or= 1
    ordinal = @_nextIdPerClass[className]++

    "#{className}#{ordinal}#{detail}"


  # Register the given klass.
  register: (klass) ->
    kind = R.kindFromClass(klass)

    # We may have multiple classes for the same entity, they will be all merged together (kinda like Ruby modules).
    if @kinds.hasOwnProperty(kind)
      schema = @kinds[kind]
    else
      schema = @kinds[kind] = new REntitySchema(this, kind)
    schema.addClass klass

    return schema

  findEntityKind: (kind) ->
    if @kinds.hasOwnProperty(kind) then @kinds[kind] else null


  # Create a new entity of the specified kind.
  create: (kind, attributes) ->
    schema = @findEntityKind(kind) or throw new Error "R.create: unknown entity kind '#{kind}'"
    return schema.create(this, attributes)


  reading: (entity, topic) ->
    debug "#{this}: reading #{entity}.#{topic}, currentTask = #{@currentTask}"
    if task = @currentTask
      task._r_reading(entity, topic)

  broadcast: (entity, topic) ->
    debug "#{this}: change #{entity}.#{topic}"
    for own dependentId, dependent of entity.subscribers
      dependent._r_changed(entity, topic)

  # Unsubscribes the given dependent from this entity's notifications and then,
  # if topicSet is provided, resubscribes to the given list of topics.
  subscribe: (dependent, entity, topicSet) ->
    unless dependent._r_id
      throw new new Error "EINVAL: dependent must have _r_id"
    if topicSet
      entity.subscribers[dependent._r_id] = dependent
    else
      delete entity.subscribers[dependent._r_id]

  # TODO.
  enqueue: (taskDef, func) ->
    if typeof func isnt 'function'
      throw new Error "R.Universe.enqueue: func is not a function"
    process.nextTick func


# Stores all the information known about a specific kind (by a specific universe).
class REntitySchema
  constructor: (@universe, @kind) ->
    @klasses = []
    @attributes = {}

    @EntityClass = createNamedSubclass(@kind, REntity)
    @EntityClass::schema = @EntityClass.schema = this
    @EntityClass::universe = @EntityClass.universe = @universe

  # For debugging only.
  toString: -> "REntitySchema(#{@kind})"

  addClass: (klass) ->
    if @klasses.indexOf(klass) < 0
      @klasses.push klass

      for own key, value of klass.prototype when key != 'schema'
        @EntityClass::[key] = value

      # `klass::schema` looks nicer in CoffeeScript, but `klass.schema` makes more sense,
      # so we support both
      @_addSchema(klass.schema or klass::schema or {}, klass.prototype)

  create: (owner, attributes) ->
    return new @EntityClass(owner, @kind, attributes)

  initialize: (entity) ->
    for own attrName, attr of @attributes
      attr.initialize(entity)

  _addSchema: (schema, prototype) ->
    for own attrName, attrOptions of schema
      @_addAttribute attrName, attrOptions, prototype
    undefined

  _addAttribute: (attrName, attrOptions, prototype) ->
    # Convert magic methods into options.
    for own optionsKey, methodName of MAGIC_METHODS
      @_convertMethodIntoOption prototype, attrOptions, methodName.replace('%', attrName), optionsKey

    attrSchema = @attributes[attrName] = new RAttributeSchema(this, attrName, attrOptions)
    attrSchema.implement(@EntityClass::)

  _convertMethodIntoOption: (prototype, options, methodName, optionsKey) ->
    if prototype.hasOwnProperty(methodName)
      options[optionsKey] = prototype[methodName]
      delete prototype[methodName]


class RAttributeSchema
  constructor: (@entitySchema, @name, @options) ->
    @field = "_#{@name}"

    if @options.compute
      @computeTaskDef = new R.TaskDef(@universe, "compute #{@name}", R.TaskDef.AUTOREPEAT, @_recomputeValue.bind(@))

  # For debugging only.
  toString: ->
    "RAttributeSchema(#{@name}, #{JSON.stringify(@options)})"

  Object.defineProperty @::, 'universe', get: ->
    @entitySchema.universe

  initialize: (entity) ->
    entity[@field] = null
    if @computeTaskDef
      new R.Task(entity, @computeTaskDef)

  implement: (prototype) ->
    universe = @universe
    name     = @name
    field    = @field

    Object.defineProperty prototype, @name,
      enumerable: yes
      configurable: yes
      get: ->
        universe.reading(this, name)
        return this[field]
      set: (value) ->
        if this[field] != value
          this[field] = value
          universe.broadcast(this, name)

  _recomputeValue: (entity) ->
    oldValue = entity[@field]
    newValue = @options.compute.call(entity)
    if newValue != oldValue
      entity[@field] = newValue
      @universe.broadcast(entity, @name)

class REntity
  # For duck type checks.
  isReactiveEntity: yes

  constructor: (owner, @kind, attributes) ->
    @_r_id = @universe.uniqueId(this.constructor.name)

    # TODO: notify these parts when disposing the entity.
    @parts = []

    @subscribers = {}

    # Attribute initializers may be creating parts, so this must be done after initializing our fields.
    @schema.initialize(this)

    for key, value of attributes
      @set(key, value)

  # For debugging only
  toString: -> @_r_id

  get: (attr) ->
    if @schema.attributes.hasOwnProperty(attr)
      return this[attr]
    else
      throw new Error "Unknown attribute '#{attr}'"

  set: (attr, value) ->
    if @schema.attributes.hasOwnProperty(attr)
      this[attr] = value
    else
      throw new Error "Unknown attribute '#{attr}'"

  _r_addPart: (part) ->
    @parts.push part


# An object which does not have its own identity, instead sharing the identity of its owner.
class RPart extends EventEmitter

  constructor: (@owner) ->
    unless @owner? then throw new Error "RPart owner must be provided"
    unless @owner.isReactiveEntity then throw new Error "RPart owner must be an entity"

    @_r_id = @universe.uniqueId(this.constructor.name, @_r_detail)

    @disposed = no
    @owner._r_addPart(this)

  toString: -> @_r_id

  Object.defineProperty @::, 'universe', get: ->
    @owner.universe

  dispose: ->
    return if @disposed
    @disposed = yes

    @owner._r_removePart(this)
    @owner = null


class RTaskInvocation
  constructor: (@task) ->
    @_r_id = @universe.uniqueId(this.constructor.name)

    @complete = no
    @error    = null
    @result   = undefined

    # node domain for all callbacks executed on behalf of this invocation
    @domain = Domain.create()

    # callbacks to be notified when the invocation is complete
    @completionCallbacks = []

    # callbacks to be notified when the invocation is finalized
    @finalizationCallbacks = []

    @childCount = 0
    @children = {}

    @_dependenciesById = {}
    @_topicsByDepId = {}


  Object.defineProperty @::, 'universe', get: ->
    @task.universe


  markComplete: (result, error) ->
    if @complete then throw new Error "EINVAL"

    @complete = yes
    @error    = error
    @result   = result

    if @error
      debug "#{@task} failed: #{@error.stack or @error.message or @error}"
    else
      debug "#{@task} completed successfully"

    # Emit the task-level event before calling invocation-level handlers to make testing easier.
    @task.emit 'completed', this

    for callback in @completionCallbacks
      try
        callback()
      catch err
        # In most cases, this error would be caught by the parent domain.
        console.error("Error executing task completion callback: %s", err.stack or err.message or err)
        # questionable approach, but works well in async Mocha tests
        process.nextTick -> throw err
    @completionCallbacks = null

    @_checkFinalized()


  waitCompleted: (callback) ->
    if @complete
      throw new Error "Cannot invoke waitCompleted on completed invocations"
    @completionCallbacks.push(callback)
    return this  # for chaining

  waitFinalized: (callback) ->
    if @_isFinalized()
      throw new Error "Cannot invoke waitFinalized on finalized invocations"
    @finalizationCallbacks.push(callback)
    return this  # for chaining


  addChildInvocation: (childInvocation) ->
    invocationId = childInvocation._r_id
    unless @children.hasOwnProperty(invocationId)
      ++@childCount
      @children[childInvocation._r_id] = childInvocation
      childInvocation.waitFinalized =>
        --@childCount
        delete @children[childInvocation._r_id]
        @_checkFinalized()


  _isFinalized: ->
    return @complete and (@childCount == 0)

  _checkFinalized: ->
    return unless @_isFinalized()

    debug "#{@task} finalized"

    # Emit the task-level event before calling invocation-level handlers to make testing easier.
    @task.emit 'finalized', this

    for callback in @finalizationCallbacks
      try
        callback()
      catch err
        # in most cases, this error would be caught by the parent domain
        console.error("Error executing task finalization callback: %s", err.stack or err.message or err)
        # questionable approach, but works well in async Mocha tests
        process.nextTick -> throw err
    @finalizationCallbacks = null

  _r_addDependency: (entity, topic) ->
    entityId = entity._r_id

    unless @_dependenciesById.hasOwnProperty(entityId)
      @_dependenciesById[entityId] = entity
      @_topicsByDepId[entityId] = {}

    @_topicsByDepId[entityId][topic] = yes
    undefined


R.TaskDef =
class RTaskDef
  @ONESHOT    = ONESHOT    = 'oneshot'
  @MULTISHOT  = MULTISHOT  = 'multishot'
  @AUTOREPEAT = AUTOREPEAT = 'autorepeat'

  constructor: (@universe, @name, @type, @func, options={}) ->
    unless @type in [ONESHOT, MULTISHOT, AUTOREPEAT]
      throw new Error "RTaskDef: invalid type '#{@type}'"

    @_r_id = @universe.uniqueId(this.constructor.name, @name)
    @async    = options.async ? no

    @multiuse = (@type is MULTISHOT) or (@type is AUTOREPEAT)
    @reactive = (@type is AUTOREPEAT)
    @autoschedule = options.autoschedule ? @reactive


R.Task =
class RTask extends RPart

  constructor: (owner, @taskDef) ->
    @_r_detail = @taskDef.name
    super(owner)

    @scheduledInvocation = null
    @runningInvocation   = null
    @completedInvocation = null

    if @taskDef.autoschedule
      @schedule()

  schedule: ->
    if !@taskDef.multiuse and (@runningInvocation or @completedInvocation)
      throw new Error "Cannot reschedule a non-multiuse task"

    unless @scheduledInvocation
      @scheduledInvocation = new RTaskInvocation(this)
      @universe.enqueue(@taskDef, @run.bind(@))

    if task = @universe.currentTask
      task._r_addChild(@scheduledInvocation)

    return @scheduledInvocation


  run: ->
    @runningInvocation   = @scheduledInvocation
    @scheduledInvocation = null

    @universe.currentTask = this

    if @taskDef.async
      throw new Error "Async tasks not implemented yet"
    else
      @_runSync()

  _runDone: (result, err) ->
    @universe.currentTask = null
    prevInvocation = @completedInvocation
    @completedInvocation = @runningInvocation
    @completedInvocation.markComplete(result, err)

    # TODO: subscribe before sending any events to avoid missing changes?
    if @taskDef.reactive
      oldDependencies = prevInvocation?._dependenciesById or {}
      newDependencies = @completedInvocation._dependenciesById
      newTopics = @completedInvocation._topicsByDepId

      for own entityId, entity of oldDependencies when !newDependencies.hasOwnProperty(entityId)
        @universe.subscribe(this, entity, null)
      for own entityId, entity of newDependencies
        @universe.subscribe(this, entity, @completedInvocation._topicsByDepId[entityId])

  _runSync: ->
    debug "%s running", this
    try
      result = @taskDef.func.call(@owner, @owner)
    catch err
      console.error("%s failed: %s", this, err.stack or err.message or err)
      return @_runDone(undefined, err)

    @_runDone(result, null)

  _r_addChild: (childInvocation) ->
    unless @runningInvocation
      throw new Error "Internal error: runningInvocation is null in _r_addChild"
    @runningInvocation.addChildInvocation(childInvocation)

  _r_reading: (entity, topic) ->
    if @taskDef.reactive
      debug "%s depends on %s.%s", this, entity._r_id, topic
      @runningInvocation._r_addDependency(entity, topic)

  _r_changed: (entity, topic) ->
    if @taskDef.reactive
      if topic of @completedInvocation?._topicsByDepId[entity._r_id]
        debug "#{this}: reschedule because #{entity._r_id}.#{topic} has changed"
        @schedule()
