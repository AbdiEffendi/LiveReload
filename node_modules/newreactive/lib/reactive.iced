_ = require 'underscore'
debug = require('debug')('reactive')
{EventEmitter} = require 'events'


module.exports = R =
  VERSION: '0.0.0'


# For convenience, entities support magic method names like `get myattr` (yes, with a space),
# which are automatically converted into options of the corresponding attributes.
# To help catch typos, an error is thrown if the attribute is not already defined.
# Here, `%` stands for the attribute name.
MAGIC_METHODS =
  getter: 'get %'
  setter: 'set %'
  compute: 'compute %'
  initializer: 'initialize %'


# Generate unique identifiers for everything.
R.uniqueId = _.uniqueId


# Creates an empty subclass of the given superclass, with `.constructor.name` returning the given name.
createNamedSubclass = (name, superclass) ->
  if false
    # This would be a sane way to do this if Function.name was assignable under V8.
    class subclass extends superclass
    subclass.name = name
  else
    # The insane way to create a class.
    global.REACTIVE_CLASS_CREATION_HACK = superclass
    subclass = eval("(function(superclass) { return function #{name}() { superclass.apply(this, arguments); }; })(global.REACTIVE_CLASS_CREATION_HACK);")
    delete global.REACTIVE_CLASS_CREATION_HACK
    `__extends(subclass, superclass);`  # HACK: reuse CoffeeScript's internal method
  return subclass


R.kindFromClass = (klass) ->
  # We rely on Function::name, which is a non-standard property supported by everyone except IE
  # (and can be emulated by parsing Function::toString if necessary).
  unless klass.name
    throw new Error "R requires entity classes to have a non-empty 'name'"

  # Entity name ends with the first underscore. Everything else is a SmallTalk/ObjC-style ‘category name’,
  # or a ‘mixin name’ if you will.
  return klass.name.replace(/_.*$/, '')


# A top-level context that contains all reactive stuff.
R.Universe = class RUniverse
  # Assign a unique ID to each Universe to help debugging tests (which typically create a new universe for each test).
  _nextUniverseId = 1

  constructor: ->
    @_id = "RUniverse" + (_nextUniverseId++)
    @kinds = {}

  # For debugging only.
  toString: -> @_id

  # Initiate a singularity.
  dispose: ->


  # Register the given klass.
  register: (klass) ->
    kind = R.kindFromClass(klass)

    # We may have multiple classes for the same entity, they will be all merged together (kinda like Ruby modules).
    if @kinds.hasOwnProperty(kind)
      schema = @kinds[kind]
    else
      schema = @kinds[kind] = new REntitySchema(kind)
    schema.addClass klass

    return schema

  findEntityKind: (kind) ->
    if @kinds.hasOwnProperty(kind) then @kinds[kind] else null


  # Create a new entity of the specified kind.
  create: (kind, attributes) ->
    schema = @findEntityKind(kind) or throw new Error "R.create: unknown entity kind '#{kind}'"
    return schema.create(this, attributes)


# Stores all the information known about a specific kind (by a specific universe).
class REntitySchema
  constructor: (@kind) ->
    @klasses = []
    @attributes = {}

  # For debugging only.
  toString: -> "REntitySchema(#{@kind})"

  addClass: (klass) ->
    if @klasses.indexOf(klass) < 0
      @klasses.push klass

      # `klass::schema` looks nicer in CoffeeScript class literals (just `schema: ...` instead of `@schema = ...`),
      # but klass.schema makes more sense, so let's convert the former into the latter.
      if !klass.schema and klass::schema
        klass.schema = klass::schema
        delete klass::schema

      @_addSchema(klass.schema or {}, klass.prototype)

  create: (owner, attributes) ->
    ActualEntity = createNamedSubclass(@kind, REntity)
    for mixin in @klasses
      for own key, value of mixin::
        ActualEntity::[key] = value

    ActualEntity::schema = ActualEntity.schema = this

    return new ActualEntity(owner, @kind, attributes)

  _addSchema: (schema, prototype) ->
    for own attrName, attrOptions of schema
      @_addAttribute attrName, attrOptions, prototype
    undefined

  _addAttribute: (attrName, attrOptions, prototype) ->
    # Convert magic methods into options.
    for own optionsKey, methodName of MAGIC_METHODS
      @_convertMethodIntoOption prototype, attrOptions, methodName.replace('%', attrName), optionsKey

    attrSchema = @attributes[attrName] = new RAttributeSchema(this, attrName, attrOptions)

  _convertMethodIntoOption: (prototype, options, methodName, optionsKey) ->
    if prototype.hasOwnProperty(methodName)
      options[optionsKey] = prototype[methodName]
      delete prototype[methodName]


class RAttributeSchema
  constructor: (@entitySchema, @name, @options) ->

  # For debugging only.
  toString: ->
    "RAttributeSchema(#{@name}, #{JSON.stringify(@options)})"


class REntity
  # For duck type checks.
  isReactiveEntity: yes

  constructor: (owner, @kind, attributes) ->
    for key, value of attributes
      @set(key, value)

  get: (attr) ->
    if @schema.attributes.hasOwnProperty(attr)
      return this[attr]
    else
      throw new Error "Unknown attribute '#{attr}'"

  set: (attr, value) ->
    if @schema.attributes.hasOwnProperty(attr)
      this[attr] = value
    else
      throw new Error "Unknown attribute '#{attr}'"
