_ = require 'underscore'
debug = require('debug')('reactive')
{EventEmitter} = require 'events'
Domain = require 'domain'


module.exports = R =
  VERSION: '0.0.0'


# For convenience, entities support magic method names like `get myattr` (yes, with a space),
# which are automatically converted into options of the corresponding attributes.
# To help catch typos, an error is thrown if the attribute is not already defined.
# Here, `%` stands for the attribute name.
MAGIC_METHODS =
  getter: 'get %'
  setter: 'set %'
  compute: 'compute %'
  initializer: 'initialize %'


# Creates an empty subclass of the given superclass, with `.constructor.name` returning the given name.
createNamedSubclass = (name, superclass) ->
  if false
    # This would be a sane way to do this if Function.name was assignable under V8.
    class subclass extends superclass
    subclass.name = name
  else
    # The insane way to create a class.
    global.REACTIVE_CLASS_CREATION_HACK = superclass
    subclass = eval("(function(superclass) { return function #{name}() { superclass.apply(this, arguments); }; })(global.REACTIVE_CLASS_CREATION_HACK);")
    delete global.REACTIVE_CLASS_CREATION_HACK
    `__extends(subclass, superclass);`  # HACK: reuse CoffeeScript's internal method
  return subclass


R.kindFromClass = (klass) ->
  # We rely on Function::name, which is a non-standard property supported by everyone except IE
  # (and can be emulated by parsing Function::toString if necessary).
  unless klass.name
    throw new Error "R requires entity classes to have a non-empty 'name'"

  # Entity name ends with the first underscore. Everything else is a SmallTalk/ObjC-style ‘category name’,
  # or a ‘mixin name’ if you will.
  return klass.name.replace(/_.*$/, '')


# A top-level context that contains all reactive stuff.
R.Universe = class RUniverse
  # Assign a unique ID to each Universe to help debugging tests (which typically create a new universe for each test).
  _nextUniverseId = 1

  constructor: ->
    @_id = "RUniverse" + (_nextUniverseId++)
    @_nextIdPerClass = {}
    @kinds = {}

    # A domain for generic callbacks, to be used when one needs to escape from other domains.
    @callbackDomain = Domain.create()

  # For debugging only.
  toString: -> @_id

  # Initiate a singularity.
  dispose: ->


  # Generate a human-friendly unique id.
  #
  # A simple auto-incremented number would suffice here. However, for testing
  # and debugging purposes, we choose to:
  #
  # * use class name as a prefix
  # * scope autoincremented numbers to R.Universe (so that tests can rely on stable IDs)
  # * optionally append a user-defined suffix
  uniqueId: (className='', detail) ->
    detail = if detail then ('_' + detail).replace(/[^0-9a-zA-Z]+/g, '_') else ''

    @_nextIdPerClass[className] or= 1
    ordinal = @_nextIdPerClass[className]++

    "#{className}#{ordinal}#{detail}"


  # Register the given klass.
  register: (klass) ->
    kind = R.kindFromClass(klass)

    # We may have multiple classes for the same entity, they will be all merged together (kinda like Ruby modules).
    if @kinds.hasOwnProperty(kind)
      schema = @kinds[kind]
    else
      schema = @kinds[kind] = new REntitySchema(this, kind)
    schema.addClass klass

    return schema

  findEntityKind: (kind) ->
    if @kinds.hasOwnProperty(kind) then @kinds[kind] else null

  resolveEntityKind: (kind) ->
    @findEntityKind(kind) or throw new Error "Unknown kind '#{kind}'"


  # Create a new entity of the specified kind.
  create: (kind, attributes) ->
    schema = @findEntityKind(kind) or throw new Error "R.create: unknown entity kind '#{kind}'"
    return schema.create(this, attributes)


  reading: (entity, topic) ->
    debug "#{this}: reading #{entity}.#{topic}, currentTask = #{@currentTask}"
    unless entity._r_id
      throw new Error "RUniverse.reading: entity must have _r_id"
    if task = @currentTask
      task._r_reading(entity, topic)

  broadcast: (entity, topic) ->
    debug "#{this}: change #{entity}.#{topic}"
    unless entity._r_id
      throw new Error "RUniverse.broadcast: entity must have _r_id"
    for own dependentId, dependent of entity._r_subscribers
      dependent._r_changed(entity, topic)

  # Unsubscribes the given dependent from this entity's notifications and then,
  # if topicSet is provided, resubscribes to the given list of topics.
  subscribe: (dependent, entity, topicSet) ->
    unless dependent._r_id
      throw new new Error "EINVAL: dependent must have _r_id"

    topicSetKeys = (if topicSet then Object.keys(topicSet) else null)
    debug "#{this}: subscribing #{dependent} to #{entity}, topic set #{JSON.stringify topicSetKeys}"

    wasEmpty = (Object.keys(entity._r_subscribers).length is 0)
    if topicSet and Object.keys(topicSet).length > 0
      entity._r_subscribers[dependent._r_id] = dependent
    else
      delete entity._r_subscribers[dependent._r_id]
    isEmpty = (Object.keys(entity._r_subscribers).length is 0)

    if wasEmpty != isEmpty
      if isEmpty
        entity._r_subscription_ended?()
      else
        entity._r_subscription_started?()


  Object.defineProperty @::, 'currentTask', get: ->
    Domain.active?._r_task

  # TODO.
  enqueue: (taskDef, func) ->
    if typeof func isnt 'function'
      throw new Error "R.Universe.enqueue: func is not a function"
    @callbackDomain.run ->
      process.nextTick func


# Stores all the information known about a specific kind (by a specific universe).
class REntitySchema
  constructor: (@universe, @kind) ->
    @klasses = []
    @attributes = {}
    @automaticBlockTaskDefs = []

    @EntityClass = createNamedSubclass(@kind, REntity)
    @EntityClass::schema = @EntityClass.schema = this
    @EntityClass::universe = @EntityClass.universe = @universe

  # For debugging only.
  toString: -> "REntitySchema(#{@kind})"

  addClass: (klass) ->
    if @klasses.indexOf(klass) < 0
      @klasses.push klass

      # TODO: maybe we want to avoid copying magic methods here?
      for own key, value of klass.prototype when key != 'schema'
        @EntityClass::[key] = value

      @_handleEntityWideMagicMethods(klass.prototype)

      # `klass::schema` looks nicer in CoffeeScript, but `klass.schema` makes more sense,
      # so we support both
      @_addSchema(klass.schema or klass::schema or {}, klass.prototype)

  create: (owner, attributes) ->
    return new @EntityClass(owner, @kind, attributes)

  initialize: (entity) ->
    for own attrName, attr of @attributes
      attr.initialize(entity)
    for taskDef in @automaticBlockTaskDefs
      new R.Task(entity, taskDef)

  _handleEntityWideMagicMethods: (prototype) ->
    for own key, value of prototype
      if m = key.match /^automatically_(.*)$/
        @automaticBlockTaskDefs.push new R.TaskDef(@universe, m[1], R.TaskDef.AUTOREPEAT, value)


  _addSchema: (schema, prototype) ->
    for own attrName, attrOptions of schema
      @_addAttribute attrName, attrOptions, prototype
    undefined

  _addAttribute: (attrName, attrOptions, prototype) ->
    # Convert magic methods into options.
    for own optionsKey, methodName of MAGIC_METHODS
      @_convertMethodIntoOption prototype, attrOptions, methodName.replace('%', attrName), optionsKey

    attrSchema = @attributes[attrName] = new RAttributeSchema(this, attrName, attrOptions)
    attrSchema.implement(@EntityClass::)

  _convertMethodIntoOption: (prototype, options, methodName, optionsKey) ->
    if prototype.hasOwnProperty(methodName)
      options[optionsKey] = prototype[methodName]
      delete prototype[methodName]


class RAttributeSchema
  constructor: (@entitySchema, @name, @options) ->
    @field = "_#{@name}"

    if @options.collection
      @collectionClass = @_resolveCollectionClass(@options.collection)
      @itemEntitySchema = @universe.resolveEntityKind(@options.type)

    if (typeof @options.default) isnt 'undefined'
      @defaultValue = @options.default
      @defaultValueSet = yes

    if @options.compute
      if @options.compute.length is 0
        @computeTaskDef = new R.TaskDef(@universe, "compute #{@name}", R.TaskDef.AUTOREPEAT, @_recomputeValueSync.bind(@))
      else if @options.compute.length is 1
        @computeTaskDef = new R.TaskDef(@universe, "compute #{@name}", R.TaskDef.AUTOREPEAT, @_recomputeValueAsync.bind(@))
      else
        throw new Error "Compute function for #{@entitySchema}.#{@name} has an invalid signature"

  # For debugging only.
  toString: ->
    "RAttributeSchema(#{@name}, #{JSON.stringify(@options)})"

  Object.defineProperty @::, 'universe', get: ->
    @entitySchema.universe

  initialize: (entity) ->
    entity[@field] = @_createDefaultValue(entity)
    if @computeTaskDef
      new R.Task(entity, @computeTaskDef)

  implement: (prototype) ->
    universe = @universe
    name     = @name
    field    = @field

    if @collectionClass
      descriptor =
        enumerable: yes
        configurable: yes
        get: ->
          return this[field]
        set: ->
          throw new Error "Cannot set collection property #{name}"
    else
      descriptor =
        enumerable: yes
        configurable: yes
        get: ->
          universe.reading(this, name)
          return this[field]
        set: (value) ->
          if this[field] != value
            this[field] = value
            universe.broadcast(this, name)

    Object.defineProperty prototype, @name, descriptor

  _recomputeValueSync: (entity) ->
    newValue = @options.compute.call(entity)
    @_updateComputedValue(entity, newValue)

  _recomputeValueAsync: (entity, callback) ->
    await @options.compute.call entity, defer(err, newValue)
    return callback(err) if err

    @_updateComputedValue(entity, newValue)
    callback(null)

  _updateComputedValue: (entity, newValue) ->
    oldValue = entity[@field]
    if newValue != oldValue
      if @collectionClass
        oldValue._r_updateCollection(newValue)
      else
        entity[@field] = newValue
        @universe.broadcast(entity, @name)

  _resolveCollectionClass: (type) ->
    if typeof type is 'string'
      switch type
        when 'list' then RListCollection
        else throw new Error "Unknown collection type '#{type}'"
    else if typeof type is 'function'
      type
    else
      throw new Error "Invalid type of 'collection' option: '#{type}'"

  _createDefaultValue: (entity) ->
    if @collectionClass
      new @collectionClass(entity, this)
    else if @defaultValueSet
      @defaultValue
    else
      null


class REntity
  # For duck type checks.
  isReactiveEntity: yes

  constructor: (owner, @kind, attributes) ->
    @_r_id = @universe.uniqueId(this.constructor.name)

    debug "%s created", this

    # TODO: notify these parts when disposing the entity.
    @_parts = {}

    @_r_subscribers = {}

    # Attribute initializers may be creating parts, so this must be done after initializing our fields.
    @schema.initialize(this)

    for key, value of attributes
      @set(key, value)

  # For debugging only
  toString: -> @_r_id

  get: (attr) ->
    if @schema.attributes.hasOwnProperty(attr)
      return this[attr]
    else
      throw new Error "Unknown attribute '#{attr}'"

  set: (attr, value) ->
    if @schema.attributes.hasOwnProperty(attr)
      this[attr] = value
    else
      throw new Error "Unknown attribute '#{attr}'"

  _r_addPart: (part) ->
    @_parts[part._r_id] = part

  _r_removePart: (part) ->
    delete @_parts[part._r_id]


# An object which does not have its own identity, instead sharing the identity of its owner.
class RPart extends EventEmitter

  constructor: (@owner) ->
    unless @owner? then throw new Error "RPart owner must be provided"
    unless @owner.isReactiveEntity then throw new Error "RPart owner must be an entity"

    @_r_id = @universe.uniqueId(this.constructor.name, @_r_detail)

    @disposed = no
    @owner._r_addPart(this)

  toString: -> @_r_id

  Object.defineProperty @::, 'universe', get: ->
    @owner.universe

  dispose: ->
    return if @disposed
    @disposed = yes
    @_disposed()

  _disposed: ->
    @owner._r_removePart(this)
    @owner = null


class RTaskInvocation
  constructor: (@task) ->
    @_r_id = @universe.uniqueId(this.constructor.name, @task.taskDef.name)

    @complete = no
    @error    = null
    @result   = undefined

    # node domain for all callbacks executed on behalf of this invocation
    @domain = Domain.create()
    @domain._r_task = @task
    @domain.on 'error', @handleError.bind(@)

    # callbacks to be notified when the invocation is complete
    @completionCallbacks = []

    # callbacks to be notified when the invocation is finalized
    @finalizationCallbacks = []

    @childCount = 0
    @children = {}

    @_dependenciesById = {}
    @_topicsByDepId = {}


  Object.defineProperty @::, 'universe', get: ->
    @task.universe


  handleError: (error) ->
    debug "domain.error: #{error}"
    @universe.callbackDomain.run =>
      @markComplete error, undefined


  markComplete: (error, result) ->
    if @complete then throw new Error "EINVAL"

    @complete = yes
    @error    = error
    @result   = result

    if @error
      debug "#{@task} failed: #{@error.stack or @error.message or @error}"
    else
      debug "#{@task} completed successfully"

    @domain.dispose()

    @task._r_invocationCompleted()

    # Emit the task-level event before calling invocation-level handlers to make testing easier.
    @task.emit 'completed', this

    for callback in @completionCallbacks
      try
        callback()
      catch err
        # In most cases, this error would be caught by the parent domain.
        console.error("Error executing task completion callback: %s", err.stack or err.message or err)
        # questionable approach, but works well in async Mocha tests
        process.nextTick -> throw err
    @completionCallbacks = null

    @_checkFinalized()


  waitCompleted: (callback) ->
    if @complete
      throw new Error "Cannot invoke waitCompleted on completed invocations"
    @completionCallbacks.push(callback)
    return this  # for chaining

  waitFinalized: (callback) ->
    if @_isFinalized()
      throw new Error "Cannot invoke waitFinalized on finalized invocations"
    @finalizationCallbacks.push(callback)
    return this  # for chaining


  addChildInvocation: (childInvocation) ->
    invocationId = childInvocation._r_id
    unless @children.hasOwnProperty(invocationId)
      ++@childCount
      @children[childInvocation._r_id] = childInvocation
      childInvocation.waitFinalized =>
        --@childCount
        delete @children[childInvocation._r_id]
        @_checkFinalized()


  _isFinalized: ->
    return @complete and (@childCount == 0)

  _checkFinalized: ->
    return unless @_isFinalized()

    debug "#{@task} finalized"

    # Emit the task-level event before calling invocation-level handlers to make testing easier.
    @task.emit 'finalized', this

    for callback in @finalizationCallbacks
      try
        callback()
      catch err
        # in most cases, this error would be caught by the parent domain
        console.error("Error executing task finalization callback: %s", err.stack or err.message or err)
        # questionable approach, but works well in async Mocha tests
        process.nextTick -> throw err
    @finalizationCallbacks = null

  _r_addDependency: (entity, topic) ->
    entityId = entity._r_id

    unless @_dependenciesById.hasOwnProperty(entityId)
      @_dependenciesById[entityId] = entity
      @_topicsByDepId[entityId] = {}

    @_topicsByDepId[entityId][topic] = yes
    undefined


R.TaskDef =
class RTaskDef
  @ONESHOT    = ONESHOT    = 'oneshot'
  @MULTISHOT  = MULTISHOT  = 'multishot'
  @AUTOREPEAT = AUTOREPEAT = 'autorepeat'

  constructor: (@universe, @name, @type, @func, options={}) ->
    unless @type in [ONESHOT, MULTISHOT, AUTOREPEAT]
      throw new Error "RTaskDef: invalid type '#{@type}'"

    @_r_id = @universe.uniqueId(this.constructor.name, @name)
    @async = @func.length is 2

    @multiuse = (@type is MULTISHOT) or (@type is AUTOREPEAT)
    @reactive = (@type is AUTOREPEAT)
    @autoschedule = options.autoschedule ? @reactive


R.Task =
class RTask extends RPart

  constructor: (owner, @taskDef) ->
    @_r_detail = @taskDef.name
    super(owner)

    @scheduledInvocation = null
    @runningInvocation   = null
    @completedInvocation = null

    if @taskDef.autoschedule
      @schedule()


  _disposed: ->
    if @taskDef.autoschedule and @completedInvocation
      oldDependencies = @completedInvocation?._dependenciesById or {}
      for own entityId, entity of oldDependencies
        @universe.subscribe(this, entity, null)

    super


  Object.defineProperty @::, 'lastResult', get: ->
    @completedInvocation?.result

  Object.defineProperty @::, 'lastError', get: ->
    @completedInvocation?.error


  schedule: ->
    if !@taskDef.multiuse and (@runningInvocation or @completedInvocation)
      throw new Error "Cannot reschedule a non-multiuse task"

    debug "%s scheduled", this

    unless @scheduledInvocation
      @scheduledInvocation = new RTaskInvocation(this)
      @universe.enqueue(@taskDef, @run.bind(@))

    if task = @universe.currentTask
      task._r_addChild(@scheduledInvocation)

    return @scheduledInvocation


  run: ->
    @runningInvocation   = @scheduledInvocation
    @scheduledInvocation = null

    if @taskDef.async
      @_runAsync()
    else
      @_runSync()

  _r_invocationCompleted: ->
    prevInvocation = @completedInvocation
    @completedInvocation = @runningInvocation

    # Subscribe before sending events to avoid missing changes,
    # and also so that subscriptions are all set up by the time finalize callbacks are invoked.
    if @taskDef.reactive
      oldDependencies = prevInvocation?._dependenciesById or {}
      newDependencies = @completedInvocation._dependenciesById
      newTopics = @completedInvocation._topicsByDepId

      for own entityId, entity of oldDependencies when !newDependencies.hasOwnProperty(entityId)
        @universe.subscribe(this, entity, null)
      for own entityId, entity of newDependencies
        @universe.subscribe(this, entity, @completedInvocation._topicsByDepId[entityId])

  _runSync: ->
    debug "%s running", this

    result = @runningInvocation.domain.run(@taskDef.func.bind(@owner, @owner))
    @runningInvocation.markComplete null, result

  _runAsync: ->
    debug "%s running (async)", this
    await @runningInvocation.domain.run(@taskDef.func.bind(@owner, @owner, defer(err, result)))
    @runningInvocation.markComplete err, result


  _r_addChild: (childInvocation) ->
    unless @runningInvocation
      throw new Error "Internal error: runningInvocation is null in _r_addChild"
    @runningInvocation.addChildInvocation(childInvocation)

  _r_reading: (entity, topic) ->
    if @taskDef.reactive
      debug "%s depends on %s.%s", this, entity._r_id, topic
      @runningInvocation._r_addDependency(entity, topic)

  _r_changed: (entity, topic) ->
    if @taskDef.reactive
      if topic of @completedInvocation?._topicsByDepId[entity._r_id]
        debug "#{this}: reschedule because #{entity._r_id}.#{topic} has changed"
        @schedule()


R.Collection =
class RCollection extends RPart

  constructor: (owner, @attrSchema) ->
    super(owner)
    @_initialize()
    @_queries = {}

  _initialize: ->

  at: (index) ->
    @findOne($at: index).get()

  _r_addQuery: (query) ->
    @_queries[query._r_id] = query

  _r_removeQuery: (query) ->
    delete @_queries[query._r_id]


R.ListCollection =
class RListCollection extends RCollection

  _initialize: ->
    super
    @_items = []

  push: (item) ->
    @_items.push(item)

  Object.defineProperty @::, 'all', get: ->
    new RQuery(this, RYesCondition.instance).all

  find: (criteria) ->
    new RQuery(this, RCondition.parse(criteria))

  findOne: (criteria) ->
    criteria = _.extend({ $limit: 1 }, criteria)
    new RSingleItemQuery(@find(criteria))

  _r_all_items: ->
    @_items

  _r_at: (index) ->
    return @_items[index]

  _r_updateCollection: (items) ->
    debug "#{this} _r_updateCollection: %j", items
    items = items.map(@_mapItem.bind(@))
    @_items.splice(0, @_items.length)
    @_items.push.apply(@_items, items)

  _mapItem: (item) ->
    itemEntitySchema = @attrSchema.itemEntitySchema
    if not item?
      throw new Error "Null items are not allowed in collections."
    else if typeof(item) is 'object'
      if item instanceof itemEntitySchema.EntityClass
        item
      else if item.constructor is Object
        itemEntitySchema.create(this, item)
      else
        throw new Error "Invalid item"
    else
      throw new Error "Invalid item type #{typeof item}"


class RSingleItemQuery

  constructor: (@query) ->

  Object.defineProperty @::, 'universe', get: ->
    @query.universe

  # Returns a single result, or `null` if no results are available.
  # Throws an error if more than one result is available.
  get: ->
    items = @query.all
    switch items.length
      when 0
        null
      when 1
        items[0]
      else
        throw new Error "More than 1 result"


class RQuery

  constructor: (@collection, @condition) ->
    @_r_id = @universe.uniqueId(this.constructor.name, @condition.toString())
    @_r_subscribers = {}

  toString: ->
    "RQuery< #{@collection} WHERE #{@condition} >"

  Object.defineProperty @::, 'universe', get: ->
    @collection.universe

  Object.defineProperty @::, 'all', get: ->
    @universe.reading(this, 'all')
    @condition.obtain(@collection)

  _r_subscription_started: ->
    debug "RQuery _r_subscription_started: #{this}"
    @collection._r_addQuery(this)

  _r_subscription_ended: ->
    debug "RQuery _r_subscription_ended: #{this}"
    @collection._r_removeQuery(this)


class RCondition
  @parse: (criteria) ->
    conditions = []

    if criteria.$at?
      conditions.push new RIndexMatcher(criteria.$at)

    if criteria.$limit? and not criteria.$at?
      condition.push new RLimitCondition(criteria.$limit)

    for k, v of criteria when !k.match /^\$/
      conditions.push new RAttributeEqualityMatcher(k, v)

    switch conditions.length
      when 0 then RYesCondition.instance
      when 1 then conditions[0]
      else        new RAndCondition(conditions)

  canObtainEfficiently: no

  obtain: (collection) -> @filter(collection._r_all_items())

  filter: (list) -> _.filter(list, (item) -> @matches(item))

  matches: (item) -> yes


class RYesCondition extends RCondition

  toString: ->
    '(all)'

  filter: (list) -> list

  matches: (item) -> yes

  @instance = new @()


class RAndCondition extends RCondition
  constructor: (@conditions) ->
    @_efficientObtainConditions = _.find @conditions, (condition) -> condition.canObtainEfficiently
    @canObtainEfficiently = (@_efficientObtainConditions.length > 0)

  toString: ->
    "(and " + @conditions.join(" ") + ")"

  obtain: (collection) ->
    if @canObtainEfficiently
      @filter(_.intersection.call(_, _.map @_efficientObtainConditions, (condition) -> condition.obtain(collection)))
    else
      super

  filter: (list) ->
    for condition in @conditions
      list = condition.filter(list)
    return list


class RIndexCondition extends RCondition
  constructor: (@index) ->

  toString: ->
    "($at #{@index})"

  canObtainEfficiently: yes

  obtain: (collection) ->
    if (result = collection._r_at(@index))?
      [result]
    else
      []


class RLimitCondition extends RCondition
  constructor: (@limit) ->

  toString: ->
    "($limit #{@limit})"

  filter: (list) ->
    if list.length > @limit
      list.slice(0, @limit)
    else
      list


class RAttributeEqualityCondition extends RCondition
  constructor: (@attrName, @value) ->

  toString: ->
    "(.#{@attrName} == #{@value})"

  matches: (item) ->
    item[@attrName] == @value
