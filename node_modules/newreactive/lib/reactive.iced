_ = require 'underscore'
debug = require('debug')('reactive')
{EventEmitter} = require 'events'


module.exports = R =
  VERSION: '0.0.0'


# For convenience, entities support magic method names like `get myattr` (yes, with a space),
# which are automatically converted into options of the corresponding attributes.
# To help catch typos, an error is thrown if the attribute is not already defined.
# Here, `%` stands for the attribute name.
MAGIC_METHODS =
  getter: 'get %'
  setter: 'set %'
  compute: 'compute %'
  initializer: 'initialize %'


# Creates an empty subclass of the given superclass, with `.constructor.name` returning the given name.
createNamedSubclass = (name, superclass) ->
  if false
    # This would be a sane way to do this if Function.name was assignable under V8.
    class subclass extends superclass
    subclass.name = name
  else
    # The insane way to create a class.
    global.REACTIVE_CLASS_CREATION_HACK = superclass
    subclass = eval("(function(superclass) { return function #{name}() { superclass.apply(this, arguments); }; })(global.REACTIVE_CLASS_CREATION_HACK);")
    delete global.REACTIVE_CLASS_CREATION_HACK
    `__extends(subclass, superclass);`  # HACK: reuse CoffeeScript's internal method
  return subclass


R.kindFromClass = (klass) ->
  # We rely on Function::name, which is a non-standard property supported by everyone except IE
  # (and can be emulated by parsing Function::toString if necessary).
  unless klass.name
    throw new Error "R requires entity classes to have a non-empty 'name'"

  # Entity name ends with the first underscore. Everything else is a SmallTalk/ObjC-style ‘category name’,
  # or a ‘mixin name’ if you will.
  return klass.name.replace(/_.*$/, '')


# A top-level context that contains all reactive stuff.
R.Universe = class RUniverse
  # Assign a unique ID to each Universe to help debugging tests (which typically create a new universe for each test).
  _nextUniverseId = 1

  constructor: ->
    @_id = "RUniverse" + (_nextUniverseId++)
    @_nextIdPerClass = {}
    @kinds = {}

  # For debugging only.
  toString: -> @_id

  # Initiate a singularity.
  dispose: ->


  # Generate a human-friendly unique id.
  #
  # A simple auto-incremented number would suffice here. However, for testing
  # and debugging purposes, we choose to:
  #
  # * use class name as a prefix
  # * scope autoincremented numbers to R.Universe (so that tests can rely on stable IDs)
  # * optionally append a user-defined suffix
  uniqueId: (className='', detail) ->
    detail = if detail then ('_' + detail).replace(/[^0-9a-zA-Z]+/g, '_') else ''

    @_nextIdPerClass[className] or= 1
    ordinal = @_nextIdPerClass[className]++

    "#{className}#{ordinal}#{detail}"


  # Register the given klass.
  register: (klass) ->
    kind = R.kindFromClass(klass)

    # We may have multiple classes for the same entity, they will be all merged together (kinda like Ruby modules).
    if @kinds.hasOwnProperty(kind)
      schema = @kinds[kind]
    else
      schema = @kinds[kind] = new REntitySchema(this, kind)
    schema.addClass klass

    return schema

  findEntityKind: (kind) ->
    if @kinds.hasOwnProperty(kind) then @kinds[kind] else null


  # Create a new entity of the specified kind.
  create: (kind, attributes) ->
    schema = @findEntityKind(kind) or throw new Error "R.create: unknown entity kind '#{kind}'"
    return schema.create(this, attributes)


  reading: (entity, topic) ->
    debug "#{entity}: reading #{topic}"

  broadcast: (entity, topic) ->
    debug "#{entity}: change #{topic}"

# Stores all the information known about a specific kind (by a specific universe).
class REntitySchema
  constructor: (@universe, @kind) ->
    @klasses = []
    @attributes = {}

  # For debugging only.
  toString: -> "REntitySchema(#{@kind})"

  addClass: (klass) ->
    if @klasses.indexOf(klass) < 0
      @klasses.push klass

      # `klass::schema` looks nicer in CoffeeScript class literals (just `schema: ...` instead of `@schema = ...`),
      # but klass.schema makes more sense, so let's convert the former into the latter.
      if !klass.schema and klass::schema
        klass.schema = klass::schema
        delete klass::schema

      @_addSchema(klass.schema or {}, klass.prototype)

  create: (owner, attributes) ->
    ActualEntity = createNamedSubclass(@kind, REntity)
    for mixin in @klasses
      for own key, value of mixin::
        ActualEntity::[key] = value
    for own attrName, attr of @attributes
      attr.implement(ActualEntity::)

    ActualEntity::schema = ActualEntity.schema = this
    ActualEntity::universe = ActualEntity.universe = @universe

    return new ActualEntity(owner, @kind, attributes)

  initialize: (entity) ->
    for own attrName, attr of @attributes
      attr.initialize(entity)

  _addSchema: (schema, prototype) ->
    for own attrName, attrOptions of schema
      @_addAttribute attrName, attrOptions, prototype
    undefined

  _addAttribute: (attrName, attrOptions, prototype) ->
    # Convert magic methods into options.
    for own optionsKey, methodName of MAGIC_METHODS
      @_convertMethodIntoOption prototype, attrOptions, methodName.replace('%', attrName), optionsKey

    attrSchema = @attributes[attrName] = new RAttributeSchema(this, attrName, attrOptions)

  _convertMethodIntoOption: (prototype, options, methodName, optionsKey) ->
    if prototype.hasOwnProperty(methodName)
      options[optionsKey] = prototype[methodName]
      delete prototype[methodName]


class RAttributeSchema
  constructor: (@entitySchema, @name, @options) ->
    @field = "_#{@name}"

  # For debugging only.
  toString: ->
    "RAttributeSchema(#{@name}, #{JSON.stringify(@options)})"

  Object.defineProperty @::, 'universe', get: ->
    @entitySchema.universe

  initialize: (entity) ->
    entity[@field] = null

  implement: (prototype) ->
    universe = @universe
    name     = @name
    field    = @field

    Object.defineProperty prototype, @name,
      enumerable: yes
      configurable: yes
      get: ->
        universe.reading(this, name)
        return this[field]
      set: (value) ->
        if this[field] != value
          this[field] = value
          universe.broadcast(this, name)


class REntity
  # For duck type checks.
  isReactiveEntity: yes

  constructor: (owner, @kind, attributes) ->
    @_r_id = @universe.uniqueId(this.constructor.name)

    @schema.initialize(this)
    for key, value of attributes
      @set(key, value)

  # For debugging only
  toString: -> @_r_id

  get: (attr) ->
    if @schema.attributes.hasOwnProperty(attr)
      return this[attr]
    else
      throw new Error "Unknown attribute '#{attr}'"

  set: (attr, value) ->
    if @schema.attributes.hasOwnProperty(attr)
      this[attr] = value
    else
      throw new Error "Unknown attribute '#{attr}'"
