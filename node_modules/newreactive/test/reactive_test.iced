{ ok, equal, deepEqual } = require 'assert'
_ = require 'underscore'
R = require "../#{process.env.JSLIB or 'lib'}/reactive"


Object.defineProperty R.Universe::, 'kindNames', get: ->  _.pluck(@kinds, 'kind').sort()

catchAndReturnError = (func) ->
  try func(); return null
  catch err then return err


helpers =
  usesUniverse: ->
    beforeEach -> @universe = new R.Universe()
    afterEach  -> @universe.dispose(); delete @universe
    return this

  usesLog: ->
    beforeEach ->
      @log = []
      @log.equal = (expected) => equal JSON.stringify(@log, null, 2), JSON.stringify(expected, null, 2)
      @log.pusher = (line) =>
        return =>
          @log.push(line); undefined
      @log.wrap  = (line, func) =>
        log = @log
        return (args...) ->
          log.push line
          return func.apply(this, args)
      @log.inspectTaskEvents = (task, events) ->
        if 'finalized' in events
          task.on 'finalized', @pusher("#{task}.finalized")
        if 'completed' in events
          task.on 'completed', @pusher("#{task}.completed")
        return this
    afterEach ->
      delete @log
    return this

  inspectReads: ->
    beforeEach ->
      @universe.reading = (entity, topic) =>
        @log.push "reading #{entity} #{topic}"
    return this



class MyEmptyApp

class MyApp_SomeMethods
  something: (x) -> x + 1

class MyApp_OtherMethods
  another: (x) -> x * 2

class MyApp_EventCount
  schema:
    eventCount:              { type: 'int' }


describe 'R', ->

  it "exports VERSION", ->
    ok R.VERSION.match /^\d+\.\d+\.\d+$/


describe 'R.Universe', ->
  helpers.usesUniverse()

  describe ".uniqueId(className, [detail]) return value", ->
    it "is a string", ->
      equal typeof(@universe.uniqueId('Foo')), 'string'
    it "is composed of the prefix followed by some digits", ->
      ok @universe.uniqueId('Foo').match /^Foo\d+$/
    it "is different on each call", ->
      ok @universe.uniqueId('Foo') != @universe.uniqueId('Foo')

    describe "(when the <detail> argument is specified)", ->
      it "has an alphanumeric representation of <detail> appended to the id", ->
        id = @universe.uniqueId('Foo', 'Bar Boz')
        ok id.match(/^Foo\d+_Bar_Boz$/), "id '#{id}' does not match"

  describe '#register(klass)', ->

    describe "given a regular class", ->
      beforeEach -> @universe.register(MyEmptyApp)

      it "registers a kind matching the given class name", ->
        deepEqual @universe.kindNames, ['MyEmptyApp']

      it "adds the given class to the list of the kind's mixins", ->
        deepEqual @universe.kinds.MyEmptyApp.klasses, [MyEmptyApp]

    describe "given a class with a two-part name like Foo_Bar", ->
      beforeEach -> @universe.register(MyApp_SomeMethods)

      it "uses only the first part as the entity kind", ->
        deepEqual @universe.kindNames, ['MyApp']

    describe "given multiple classes for the same entity", ->
      beforeEach -> @universe.register(MyApp_SomeMethods)
      beforeEach -> @universe.register(MyApp_OtherMethods)

      it "merges them into a single entity kind", ->
        deepEqual @universe.kindNames, ['MyApp']


  describe '#create(kind, [attributes])', ->

    describe "given a valid kind", ->
      beforeEach ->
        @universe.register(MyApp_SomeMethods)
        @entity = @universe.create('MyApp')

      it "returns a new entity of that kind", ->
        ok @entity.isReactiveEntity
        equal @entity.kind, 'MyApp'

    describe "given an unknown kind", ->
      beforeEach -> @err = catchAndReturnError => @universe.create('NonExistent')
      it "throws an error", ->
        equal @err.message, "R.create: unknown entity kind 'NonExistent'"


describe 'R.Entity', ->
  helpers.usesUniverse()


  describe ".constructor.name", ->
    beforeEach ->
      @universe.register(MyApp_SomeMethods)
      @entity = @universe.create('MyApp')
    it "matches entity kind", ->
      equal @entity.constructor.name, 'MyApp'


  describe "composed of two classes", ->

    beforeEach ->
      @universe.register(MyApp_SomeMethods)
      @universe.register(MyApp_OtherMethods)
      @entity = @universe.create('MyApp')

    it "has the methods defined in both c", ->
      equal @entity.something(10), 11
      equal @entity.another(10), 20


describe 'R.Entity attribute', ->
  helpers.usesUniverse().usesLog().inspectReads()

  describe "(a boring regular one)", ->
    beforeEach ->
      @universe.register(MyApp_EventCount)
      @entity = @universe.create('MyApp', eventCount: 10)

    it "has an AttributeSchema accessible as entity.schema.attributes.<attr>", ->
      ok @entity.schema.attributes.eventCount

    it "can be initialized by passing a value into constructor", ->
      equal @entity.eventCount, 10

    describe "when read via .get(attr)", ->
      beforeEach -> @value = @entity.get('eventCount')

      it "returns the current value", ->
        equal @value, 10

      it "records the dependency", ->
        @log.equal ["reading MyApp1 eventCount"]

    it "can be read directly", ->
      equal @entity.eventCount, 10

    it "can be set via .set()", ->
      @entity.set('eventCount', 20)
      equal @entity.eventCount, 20

    it "can be set directly", ->
      @entity.eventCount = 20
      equal @entity.eventCount, 20


  describe "not defined by the schema", ->
    beforeEach ->
      @universe.register(MyApp_EventCount)
      @entity = @universe.create('MyApp', eventCount: 10)

    it "throws an error when reading via #get", ->
      equal((catchAndReturnError => @entity.get('missingAttr'))?.message, "Unknown attribute 'missingAttr'")

    it "throws an error when writing via #set", ->
      equal((catchAndReturnError => @entity.set('missingAttr', 20))?.message, "Unknown attribute 'missingAttr'")


describe "R.Task", ->
  helpers.usesUniverse().usesLog()

  beforeEach ->
    @universe.register(MyEmptyApp)
    @entity = @universe.create('MyEmptyApp')

  describe "with ONESHOT type, sync function and no subtasks", ->
    beforeEach ->
      @task1 = new R.Task(@entity, new R.TaskDef(@universe, 'smt', R.TaskDef.ONESHOT, @log.pusher("RTask1_smt.run")))
      @log.inspectTaskEvents(@task1, ['completed', 'finalized'])

    it "reports completion and finalization", (done) ->
      await @task1.schedule().waitFinalized(defer())
      @log.equal [
        'RTask1_smt.run'
        'RTask1_smt.completed'
        'RTask1_smt.finalized'
      ]
      done()

  describe "with ONESHOT type, sync function and a subtask", ->
    beforeEach ->
      func1 = =>
        @log.push "RTask1_parent.start"
        @task2.schedule()
        @log.push "RTask1_parent.end"

      @task1 = new R.Task(@entity, new R.TaskDef(@universe, 'parent', R.TaskDef.ONESHOT, func1, multiuse: no, reactive: no))
      @task2 = new R.Task(@entity, new R.TaskDef(@universe, 'child', R.TaskDef.ONESHOT, @log.pusher("RTask2_child.run"), multiuse: no, reactive: no))
      @log.inspectTaskEvents(@task1, ['completed', 'finalized'])
        .inspectTaskEvents(@task2, ['completed', 'finalized'])

    it "reports parent task completion, then subtask completion/finalization, then parent task finalization", (done) ->
      await @task1.schedule().waitFinalized(defer())
      @log.equal [
        'RTask1_parent.start'
        'RTask1_parent.end'
        'RTask1_parent.completed'
        'RTask2_child.run'
        'RTask2_child.completed'
        'RTask2_child.finalized'
        'RTask1_parent.finalized'
      ]
      done()
